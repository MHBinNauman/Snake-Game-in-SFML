/*// Including required libraries and header files

#include <SFML/Graphics.hpp>
#include <SFML/System.hpp>
#include <SFML/Window.hpp>
#include <iostream>
#include <random>
#include <vector>
using namespace std;

const int width = 800; // Width of the Windows
const int height = 600; // Height of the Windows
const int blockSize = 20; // Size of the Fruit and the Snake

// Function to spawn the fruit at random positions
// SpawnFruit function takes a single argument which is a reference to the object named fruit

void SpawnFruitRan(sf::RectangleShape& fruit) {

	// 'random_device' is used to create an object rd that represents a source of randomness

	random_device rd;

	// rd is then used to seed the 'mt19937' object gen, 
	// which generates the random numbers used to determine the position of the fruit

	mt19937 gen(rd());

	// Seeding the 'mt19937' object with a random value from 'random_device' ensures that the 
	// sequence of random numbers generated by mt19937 is different every time the program is run

	uniform_int_distribution<int> X(0, (width - blockSize) / blockSize);
	uniform_int_distribution<int> Y(0, (height - blockSize) / blockSize);

	// 'uniform_int_distribution<int>' is a template class 
	// that generates random integers within a specified range

	fruit.setPosition(X(gen) * blockSize, Y(gen) * blockSize);

	// The setPosition method sets the position of the fruit object to the x and y coordinates 
	// generated by X(gen) and Y(gen), respectively
	// The blockSize variable is multiplied by the x and y coordinates
	//  to convert the block index to a pixel position
}

void Input(sf::RenderWindow& window, sf::Vector2i& velocity) {
	//if up arrow key is pressed and the sprite is not moving down 
	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && velocity.y != 1) {
		velocity.x = 0;
		velocity.y = -1;
	}
	//if down arrow key is pressed and the sprite is not moving up
	else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down) && velocity.y != -1) {
		velocity.x = 0;
		velocity.y = 1;
	}
	//if Left arrow key is pressed and the sprite is not moving right
	else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left) && velocity.x != 1) {
		velocity.x = -1;
		velocity.y = 0;
	}
	//if right arrow key is pressed and the sprite is not moving left
	else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) && velocity.x != -1) {
		velocity.x = 1;
		velocity.y = 0;
	}
}

void CheckCollision(sf::RectangleShape& snake, std::vector<sf::Vector2i>& tail, bool& gameOver) {
	sf::Vector2f position = snake.getPosition(); // Gets the position of the snake

	//  If a boundary collision is detected, gameOver is set to true and the function returns

	if (position.x < 0 || position.x >= width || position.y < 0 || position.y >= height) {
		gameOver = true;
		return;
	}

	// If a collision with the tail is detected, gameOver is set to true and the function returns

	for (const auto& part : tail) 
	// Range-based for loop that iterates through each element in the tail vector
	// 'auto& part' is used to declare a reference variable 'part' that is automatically deduced
	//  to be of the same type as the elements in the 'tail' vector
	{
		if (position == sf::Vector2f(part)) {
			gameOver = true;
			return;
		}
	}
}

// Updates the snake's tail by shifting the positions. 
// Removes the last position and adds the current head position to the front, 
// effectively creating a trail effect.

void updatetail(sf::RectangleShape& snake, std::vector<sf::Vector2i>& tail, sf::Vector2i& velocity) {
	if (!tail.empty()) {
		tail.pop_back();
		tail.insert(tail.begin(), sf::Vector2i(snake.getPosition()));
	}
}

void drawTail(sf::RenderWindow& window, const std::vector<sf::Vector2i>& tail) {
	sf::RectangleShape tailPart;
	tailPart.setSize(sf::Vector2f(blockSize, blockSize));
	tailPart.setFillColor(sf::Color::Green);

	for (const auto& part : tail) 
	//range - based for loop that iterates through the elements in the tail vector.
	{
	// Sets the position of the 'tailPart' object to the x and y coordinates of the current element 
	// in the tail vector.
		tailPart.setPosition(part.x, part.y);
		// Draws the tailPart object on the window.
		window.draw(tailPart);
	}
}

//Updates the score each time the snake eats the fruit

void UpdateScore(sf::RenderWindow& window, int score) {
	window.clear();
	window.setFramerateLimit(1);
	sf::Font font;
	font.loadFromFile("arial.ttf");
	sf::Text text;
	text.setFont(font);
	text.setString("Score: " + to_string(score));
	text.setCharacterSize(20);
	text.setFillColor(sf::Color::White);
	text.setPosition(width / 80, height / 60);
	window.draw(text);
	window.display();
	window.setFramerateLimit(10);
}

// The GameOverScreen function displays text "Game Over!" and the score

void GameOverScreen(sf::RenderWindow& window, int score) {
	window.clear();
	window.setFramerateLimit(1);
	sf::Font font;
	font.loadFromFile("arial.ttf");
	sf::Text text("Game Over! Score: " + to_string(score), font);
	text.setCharacterSize(30);
	text.setFillColor(sf::Color::White);
	text.setPosition(width / 2 - 150, height / 2 - 15);
	window.draw(text);
	window.display();
	window.setFramerateLimit(10);
}

int main() {
	sf::RenderWindow window(sf::VideoMode(width, height), "Snake Game");
	sf::RenderWindow window1(sf::VideoMode(width, height), "Main Menu");
	window1.setFramerateLimit(60);

	sf::RectangleShape snake(sf::Vector2f(blockSize, blockSize));
	snake.setFillColor(sf::Color::Green);
	sf::RectangleShape fruit(sf::Vector2f(blockSize, blockSize));
	fruit.setFillColor(sf::Color::Red);

	sf::Clock clock; // clock object measures the time elapsed between frames
	sf::Time elapsed; // elapsed object used to store the elapsed time between frames

	// velocity(0, 0) is an object that represents the velocity of the snake object. 
	// The initial value of the velocity is (0, 0), which means that the snake object is not moving.

	sf::Vector2i velocity(0, 0);
	vector<sf::Vector2i> tail; // Tail of the snake which is initially empty
	int score = 0;
	bool gameover = false;

	snake.setPosition(width / 2, height / 2);
	SpawnFruitRan(fruit);

	while (window1.isOpen()) {
		sf::Event event;
		while (window1.pollEvent(event)) {
			if (event.type == sf::Event::Closed) {
				window1.close();
			}
		}

		// Main Menu Winodw

		window1.clear(); // Clear function to clear the window

		// Play bar on Main Menu

		sf::RectangleShape play;
		play.setSize(sf::Vector2f(240, 50));
		play.setFillColor(sf::Color::Green);
		play.setPosition(width / 2 - 125, height / 2 - 50);
		window1.draw(play);

		// Exit bar on Main Menu

		sf::RectangleShape exit;
		exit.setSize(sf::Vector2f(240, 50));
		exit.setFillColor(sf::Color::Red);
		exit.setPosition(width / 2 - 125, height / 2 + 30);
		window1.draw(exit);

		// Loading Arial Font from a Arial.ttf file

		sf::Font font;
		font.loadFromFile("arial.ttf"); // "arial.ttf" file has been installed

		// Diplaying Play text on Main Menu

		sf::Text textp("Press P to Play the game", font);
		textp.setCharacterSize(20);
		textp.setFillColor(sf::Color::White);
		textp.setPosition(width / 2 - 120, height / 2 - 40);
		window1.draw(textp);

		// Diplaying Exit text on Main Menu

		sf::Text texte("Press E to Exit", font);
		texte.setCharacterSize(20);
		texte.setFillColor(sf::Color::White);
		texte.setPosition(width / 2 - 80, height / 2 + 40);
		window1.draw(texte);
		window1.display(); // Display function to display the data stored in the buffer

		if (sf::Keyboard::isKeyPressed(sf::Keyboard::P)) {

			// Closing Main Menu

			window1.close();

			// Creating the window of the Snake Game

			window.create(sf::VideoMode(width, height), "Snake Game");
			window.clear();
			window.setFramerateLimit(10);

			// Opening the Snake Game
			while (window.isOpen() && !window1.isOpen()) {
				elapsed = clock.restart(); // Setting elapsed time between frames to nill
				
				sf::Event event; // Creating an event in the window
				while (window.pollEvent(event)) {
					if (event.type == sf::Event::Closed) {
						window.close(); // Closes window when window is closed by clicking cross button
					}
				}

				Input(window, velocity);
				// Moves the 'snake' rectangle as per the key entered
				snake.move(velocity.x * blockSize, velocity.y * blockSize); 

				// CheckCollision function checks whether the snake colided with the borders or its tail
				CheckCollision(snake, tail, gameover);

				// Updates the score when the snake eats the fruit, displays the score and makes the snake longer

				if (snake.getPosition() == fruit.getPosition()) {
					score += 10;
					UpdateScore(window, score);
					SpawnFruitRan(fruit);
					tail.push_back(sf::Vector2i(snake.getPosition()));
				}

				// UpdateTail function creates a trailing effect

				updatetail(snake, tail, velocity);

				window.clear(); // Clears the window
				window.draw(fruit); // Draws the fruit on the window
				window.draw(snake); // Draws the snake on the window
				drawTail(window, tail); // Draws the new tail of the snake

				if (gameover) {
					GameOverScreen(window, score); // Displays the game over screen on the window
					score = 0;
					gameover = false;
					snake.setPosition(width / 2, height / 2);
					tail.clear(); // Clear the tail
					velocity = sf::Vector2i(0, 0); // Set the velocity vector to (0, 0)
					SpawnFruitRan(fruit);
					window1.create(sf::VideoMode(width, height), "Main Menu");
				}
				
				window.display(); //Displays the data stored in the buffer on the screen
			}
		} 

		// Exits the game

		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::E)) {
			window1.close();
			gameover = true;
		}
	}

	return 0;
}*/

//Including required libraries and header files

#include <SFML/Graphics.hpp>          //graphics header file from sfml library used for all the graphic operations such as drawing the snake & fruit               
#include <SFML/System.hpp>     //system header file from sfml library for system operations like timing etc.
#include <SFML/Window.hpp>     //window header file from sfml library for window creation and manipulation operation
#include <iostream>            //iostream i.e. input output stream for input and output operations
#include <random>             //<random> is a header file from the Standard C++ Library used for operations that require random number generation
#include <vector>             // <vector> is also a header file from the standard C++ Library used for vector manipulation


using namespace std;

////////////////Initializing the coordinates of the game window and block size of the game elements i.e. the fruit and snake.////////////

const int width = 800;         // Width of the Windows
const int height = 600;        // Height of the Windows
const int blockSize = 20;      // Size of the Fruit and the Snake

//////////////////////////// Function to spawn the fruit at random positions/////////////////////////////////
//spawn means the appearance of a new entity, here its our fruit

// SpawnFruit function takes a single argument which is a reference to the object named fruit
void SpawnFruitRan(sf::RectangleShape& fruit) {

	/* Initialize a random number generator using a hardware-based random seed, this is to generate random unique coordinates
	   for the fruit positions*/

	random_device rd;             // Get a random seed from the computer
	mt19937 gen(rd());            // Initialize the random number generator with the seed

	/* 'uniform_int_distribution<int>' is a class that generates random integers within a specific range.
		These integers represent the coordinates of the new positions of the fruit.*/

	uniform_int_distribution<int> X(0, (width - blockSize) / blockSize);
	uniform_int_distribution<int> Y(0, (height - blockSize) / blockSize);

	/* The setPosition method sets the position of the fruit object to the x and y coordinates
	 generated by X(gen) and Y(gen), respectively.
	 The blockSize variable is multiplied by the x and y coordinates
	  to convert the block index to a pixel position*/
	fruit.setPosition(X(gen) * blockSize, Y(gen) * blockSize);
}

///////////////////////input function; used for input detection and action //////////////////////////////
void Input(sf::RenderWindow& window, sf::Vector2i& direction) {

	//if up arrow key is pressed and the sprite is not moving down 
	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && direction.y != 1) {
		direction.x = 0;
		direction.y = -1;
	}
	//if down arrow key is pressed and the sprite is not moving up
	else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down) && direction.y != -1) {
		direction.x = 0;
		direction.y = 1;
	}
	//if Left arrow key is pressed and the sprite is not moving right
	else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left) && direction.x != 1) {
		direction.x = -1;
		direction.y = 0;
	}
	//if right arrow key is pressed and the sprite is not moving left
	else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) && direction.x != -1) {
		direction.x = 1;
		direction.y = 0;
	}
}

///////////////////////Function that checks collision////////////////////////////////
void CheckCollision(sf::RectangleShape& snake, std::vector<sf::Vector2i>& tail, bool& gameOver) {
	sf::Vector2f position = snake.getPosition(); // Gets the position of the snake

	//  If a boundary collision is detected, gameOver is set to true and the function returns

	if (position.x < 0 || position.x >= width || position.y < 0 || position.y >= height) {
		gameOver = true;
		return;
	}

	////////////collision with tail//////////////

	// Iterate over each element in the tail vector using a classic for loop
	for (size_t i = 0; i < tail.size(); ++i) {
		// Check if the position of the snake's head is equal to the position of the current tail part
		if (position == sf::Vector2f(tail[i])) {
			// If a collision with the tail is detected, set gameOver to true and return from the function
			gameOver = true;
			return;
		}
	}
}

/* Updates the snake's tail by shifting the positions.
   Removes the last position and adds the current head position to the front,
   effectively creating a trail effect.*/

void updatetail(sf::RectangleShape& snake, std::vector<sf::Vector2i>& tail, sf::Vector2i& velocity) {
	if (!tail.empty()) {
		tail.pop_back();
		tail.insert(tail.begin(), sf::Vector2i(snake.getPosition()));
	}
}

void drawTail(sf::RenderWindow& window, const std::vector<sf::Vector2i>& tail) {
	//drawing the tail
	sf::RectangleShape tailPart;
	tailPart.setSize(sf::Vector2f(blockSize, blockSize));
	tailPart.setFillColor(sf::Color::Green);

	/*range - based for loop that iterates through the elements in the tail vector.
	Sets the position of the 'tailPart' object to the x and y coordinates of the current element  in the tail vector.*/
	for (const auto& part : tail)
	{

		tailPart.setPosition(part.x, part.y);
		// Draws the tailPart object on the window.
		window.draw(tailPart);
	}
}

//Updates the score each time the snake eats the fruit

void UpdateScore(sf::RenderWindow& window, int score) {
	window.clear();
	window.setFramerateLimit(1);
	sf::Font font;
	font.loadFromFile("arial.ttf");
	sf::Text text;
	text.setFont(font);
	text.setString("Score: " + to_string(score));
	text.setCharacterSize(20);
	text.setFillColor(sf::Color::White);
	text.setPosition(width / 80, height / 60);
	window.draw(text);
	window.display();
	window.setFramerateLimit(10);
}

// The GameOverScreen function displays text "Game Over!" and the score

void GameOverScreen(sf::RenderWindow& window, int score) {
	window.clear();
	window.setFramerateLimit(1);
	sf::Font font;
	font.loadFromFile("arial.ttf");
	sf::Text text("Game Over! Score: " + to_string(score), font);
	text.setCharacterSize(30);
	text.setFillColor(sf::Color::White);
	text.setPosition(width / 2 - 200, height / 2 - 15);
	window.draw(text);
	window.display();
	window.setFramerateLimit(10);
}

int main() {

	////////////Creating two windows, one for the game and one for the main menu//////////////
	sf::RenderWindow window(sf::VideoMode(width, height), "Snake Game");
	sf::RenderWindow window1(sf::VideoMode(width, height), "Main Menu");
	window1.setFramerateLimit(60);

	///////////////Drawing the game elements i.e snake and fruit//////////////////
	sf::RectangleShape snake(sf::Vector2f(blockSize, blockSize));
	snake.setFillColor(sf::Color::Green);
	sf::RectangleShape fruit(sf::Vector2f(blockSize, blockSize));
	fruit.setFillColor(sf::Color::Red);

	sf::Clock clock; // clock object measures the time elapsed between frames
	sf::Time elapsed; // elapsed object used to store the elapsed time between frames

	// direction(0, 0) is an object that represents the velocity of the snake object. 
	// The initial value of the velocity is (0, 0), which means that the snake object is not moving.

	sf::Vector2i direction(0, 0);
	vector<sf::Vector2i> tail; // Tail of the snake which is initially empty
	int score = 0;
	bool gameover = false;

	//set position of snake
	snake.setPosition(width / 2, height / 2);
	SpawnFruitRan(fruit);

	while (window1.isOpen()) {
		sf::Event event;
		while (window1.pollEvent(event)) {
			if (event.type == sf::Event::Closed) {
				window1.close();
			}
		}

		// Main Menu Winodw

		window1.clear(); // Clear function to clear the window

		// Play bar on Main Menu

		sf::RectangleShape play;
		play.setSize(sf::Vector2f(240, 50));
		play.setFillColor(sf::Color::Green);
		play.setPosition(width / 2 - 125, height / 2 - 50);
		window1.draw(play);

		// Exit bar on Main Menu

		sf::RectangleShape exit;
		exit.setSize(sf::Vector2f(240, 50));
		exit.setFillColor(sf::Color::Red);
		exit.setPosition(width / 2 - 125, height / 2 + 30);
		window1.draw(exit);

		// Loading Arial Font from a Arial.ttf file

		sf::Font font;
		font.loadFromFile("arial.ttf"); // "arial.ttf" file has been installed

		// Diplaying Play text on Main Menu

		sf::Text textp("Press P to Play the game", font);
		textp.setCharacterSize(20);
		textp.setFillColor(sf::Color::White);
		textp.setPosition(width / 2 - 120, height / 2 - 40);
		window1.draw(textp);

		// Diplaying Exit text on Main Menu

		sf::Text texte("Press E to Exit", font);
		texte.setCharacterSize(20);
		texte.setFillColor(sf::Color::White);
		texte.setPosition(width / 2 - 80, height / 2 + 40);
		window1.draw(texte);
		window1.display(); // Display function to display the data stored in the buffer

		if (sf::Keyboard::isKeyPressed(sf::Keyboard::P)) {

			// Closing Main Menu

			window1.close();

			// Creating the window of the Snake Game

			window.create(sf::VideoMode(width, height), "Snake Game");
			window.clear();
			window.setFramerateLimit(10);

			// Opening the Snake Game
			while (window.isOpen() && !window1.isOpen()) {
				elapsed = clock.restart(); // Setting elapsed time between frames to nill

				sf::Event event; // Creating an event in the window
				while (window.pollEvent(event)) {
					if (event.type == sf::Event::Closed) {
						window.close(); // Closes window when window is closed by clicking cross button
					}
				}

				Input(window, direction);
				// Moves the 'snake' rectangle as per the key entered
				snake.move(direction.x * blockSize, direction.y * blockSize);

				// CheckCollision function checks whether the snake colided with the borders or its tail
				CheckCollision(snake, tail, gameover);

				// Updates the score when the snake eats the fruit, displays the score and makes the snake longer

				if (snake.getPosition() == fruit.getPosition()) {
					score += 10;
					UpdateScore(window, score);
					SpawnFruitRan(fruit);
					tail.push_back(sf::Vector2i(snake.getPosition()));
				}

				// UpdateTail function creates a trailing effect

				updatetail(snake, tail, direction);

				window.clear(); // Clears the window
				window.draw(fruit); // Draws the fruit on the window
				window.draw(snake); // Draws the snake on the window
				drawTail(window, tail); // Draws the new tail of the snake

				if (gameover) {
					GameOverScreen(window, score); // Displays the game over screen on the window
					score = 0;
					gameover = false;
					snake.setPosition(width / 2, height / 2);
					tail.clear(); // Clear the tail
					direction = sf::Vector2i(0, 0); // Set the velocity vector to (0, 0)
					SpawnFruitRan(fruit);
					window1.create(sf::VideoMode(width, height), "Main Menu");
				}

				window.display(); //Displays the data stored in the buffer on the screen
			}
		}

		// Exits the game

		else if (sf::Keyboard::isKeyPressed(sf::Keyboard::E)) {
			window1.close();
			gameover = true;
		}
	}

	return 0;
}